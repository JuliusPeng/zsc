pragma solidity ^0.4.11;

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

contract SafeMath {
    function safeMul(uint a, uint b) 
        internal 
        returns (uint) 
    {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) 
        internal returns (uint) 
    {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) 
        internal 
        returns (uint) 
    {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }

    function assert(bool assertion) 
        internal 
    {
        if (!assertion) throw;
    }
}

contract ZSCEntity {
    string  _name = 'NULL';  
    uint    _id = 0;
    uint    _type = 0;
    bool    _activated = false;
    address _owner = 0;
    uint    _ethValue = 0;
    uint    _zscValue = 0;

    modifier onlyOwner(address msger)  {
        if (msger != _owner) throw;
        _;
    }

    // Constructor
    function ZSCEntity(string name_, uint id_) 
    {
        _name = name_;
        _id   = id_;
        _owner = msg.sender;
    }

    // This unnamed function is called whenever someone tries to send ether to it 
    function() 
       payable
    {
        if (msg.value > 0) {
            _ethValue += msg.value;
            //Deposit(msg.sender, msg.value);
        }
    }

    function name() 
        public
        onlyOwner(msg.sender)
        constant 
        returns (string) 
    {   
        if (isOwner(msg.sender))
            return _name;
        } else {
            return 'NULL';
        }
    }

    function type() 
        public
        onlyOwner(msg.sender)
        constant 
        returns (unit) 
    {   
        if (isOwner(msg.sender)) {
            return _type;
        } else {
            return 0;
        }
    }

    function id() 
        public
        onlyOwner(msg.sender)
        constant 
        returns (unit) 
    {   
        if (isOwner(msg.sender)) {
            return _id;
        } else {
            return 0;
        }
    }

    function activated() 
        public
        onlyOwner(msg.sender)
        constant 
        returns (bool) 
    {   
        if (isOwner(msg.sender)) {
            return _activated;
        } else {
            return false;
        }
    }

    function setType(uint type_) 
        public
        onlyOwner(msg.sender)
    { 
        _type = type_;
    }
    
    function setStatus(bool status_) 
        public
        onlyOwner(msg.sender)
    {   
        _activated = status_; 
    }
}

contract ZSCUser is ZSCEntity, SafeMath {
    // Constructor
    function ZSCUser() 
        public
        ZSCEntity(msg.sender)
    {
    }
}

contract ZSCContract is ZSCEntity {
    mapping(address => unit) _providers;
    mapping(address => unit) _receivers;
    uint _totalPercentage; //range (0, 10000)

    modifier percentageRange(uint value_)  {
        if (value_ <0 || value_ >10000) throw;
        _;
    }
    // Constructor
    function ZSCContract() 
        public
        ZSCEntity(msg.sender)
    {
    }

    function addProvider(address usr_, unit percentage_) 
        public
        percentageRange
    {
        _providers[usr_] = percentage_;
    }

    function addReceiver(address usr_, unit percentage_) 
        public
        percentageRange
    {
        _receivers[usr_] = percentage_;
    }
}

contract ZSCDatabaseUser is owned, SafeMath {
    uint _startIndex = 10000;
    uint _nos = 0;
    ZSCUser[] _users;
    mapping (string => uint) _exist;

    // Constructor
    function ZSCDatabaseUser() 
        public
    {
    }

    function insertUser(string name_) 
        public
        onlyOwner
    {
        if (_exist[name_] == 0) throw;
        uint id = _nos + _startIndex;

        ZSCUser user = new ZSCUser(name_, id);
        _users[_nos] = address(user);
        _exist[name_] = id;
        _nos++;
    }

    function userId(string name_)
        internal
        constant
        return (uint)
    {
        if (_exist[name_] == 0) throw;
        return (_exist[name_] - _startIndex);
    }

    function modifyUserById(uint id_, unit type_, bool status_) 
        public
        onlyOwner
    {
        uint index = id_ - _startIndex;
        if (index >= _nos) throw;

        ZSCUser user = ZSCUser(_users[index]);
        user.setType(type_);
        user.setStatus(status_);
    }

    function modifyUserByName(string name_, unit type_, bool status_) 
        public
        onlyOwner
    {
        modifyUserById(userIdByName(name_), type_, status_);
    }

    function getUserById(uint id_) 
        public
        onlyOwner
        constant
        returns (address)
    {
        uint index = id_ - _startIndex;
        if (index >= _nos) throw;

        return _users[index];
    }

    function getUserByName(string name_) 
        public
        onlyOwner
        constant
        returns (address)
    {
        return getUserById(userIdByName(name_));
    }
}
